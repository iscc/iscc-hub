# generated by datamodel-codegen:
#   filename:  openapi.yaml

from __future__ import annotations

from typing import Annotated, Literal

from ninja import Schema
from pydantic import AnyUrl, AwareDatetime, ConfigDict, Field, RootModel


class ErrorDetail(Schema):
    model_config = ConfigDict(
        extra="forbid",
    )
    message: Annotated[
        str,
        Field(description="Human-readable error message describing the error encountered\n"),
    ]
    code: Annotated[
        str | None,
        Field(
            description="Machine-readable error code for programmatic handling.\nCommon codes: invalid_iscc, timestamp_out_of_range, invalid_signature,\nduplicate_declaration, validation_failed, nonce_mismatch, invalid_length,\ninvalid_format, invalid_hex, nonce_reuse, duplicate_datahash\n"
        ),
    ] = None
    field: Annotated[
        str | None,
        Field(
            description="The specific field that caused the error (for validation errors).\nOnly present when the error is associated with a specific input field.\n"
        ),
    ] = None


class ErrorResponse(Schema):
    model_config = ConfigDict(
        extra="forbid",
    )
    error: Annotated[ErrorDetail, Field(title="ErrorDetail")]


class Proof(Schema):
    model_config = ConfigDict(
        extra="forbid",
    )
    field_context: Annotated[
        list[str],
        Field(
            alias="@context",
            description="JSON-LD context copied from credential root (W3C spec requirement)\n",
            examples=[["https://www.w3.org/ns/credentials/v2"]],
            min_length=1,
        ),
    ]
    type: Literal["DataIntegrityProof"]
    cryptosuite: Literal["eddsa-jcs-2022"]
    verificationMethod: Annotated[
        AnyUrl,
        Field(
            description="DID URL of the HUB's signing key\n",
            examples=["did:web:testserver#z6MkkRXoNEjqGNKHrPh8a54g6B2kqLp5M6HyA7odbCh1mDwX"],
        ),
    ]
    proofPurpose: Literal["assertionMethod"]
    proofValue: Annotated[
        str,
        Field(
            description="Multibase-encoded signature value\n\n**Format:** z-base58-btc encoding\n",
            pattern="^z[1-9A-HJ-NP-Za-km-z]+$",
        ),
    ]


class IsccId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Unique ISCC-ID assigned by the ISCC-HUB\n\n**Format:** `ISCC:` followed by 16 characters encoding timestamp and hub ID\n**Structure:** 64-bit identifier (52-bit timestamp + 12-bit hub ID)\n",
            examples=["ISCC:MAACCD3C6YZJ4IQM", "ISCC:MAACEF5G8YZJ7KLN"],
            max_length=21,
            min_length=21,
            pattern="^ISCC:[A-Z0-9]{16}$",
        ),
    ]


class Unit(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Individual ISCC-UNIT (Meta, Content, Data, Instance, or Semantic)\n**Length:** 21 characters (64-bit) or 60+ characters (256-bit)\n",
            max_length=73,
            min_length=21,
            pattern="^ISCC:[A-Z0-9]{16,68}$",
        ),
    ]


class Timestamp(RootModel[AwareDatetime]):
    root: Annotated[
        AwareDatetime,
        Field(
            description="RFC 3339 formatted timestamp of IsccNote creation time in UTC with millisecond precision\n\n**Format:** `YYYY-MM-DDTHH:MM:SS.sssZ`\n**Example:** `2025-08-04T12:34:56.789Z`\n\n**Requirements:**\n- The `Z` suffix MUST be used to indicate UTC\n- Indicates when the IsccNote was created and signed\n- HUBs MUST reject timestamps outside Â±10 minutes from current time\n",
            examples=["2025-01-15T12:00:00.000Z", "2025-08-12T14:30:00.123Z"],
        ),
    ]


class Nonce(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Unique 128-bit random value for replay protection\n\n**Format:** 32 lowercase hex characters\n**Structure:** First 12 bits encode the target hub_id (0-4095)\n",
            examples=[
                "000faa3f18c7b9407a48536a9b00c4cb",
                "001234567890abcdef1234567890abcd",
            ],
            max_length=32,
            min_length=32,
            pattern="^[0-9a-f]{32}$",
        ),
    ]


class IsccSignature(Schema):
    model_config = ConfigDict(
        extra="forbid",
    )
    version: Annotated[
        Literal["ISCC-SIG v1.0"],
        Field(description="Version of the ISCC Signature format (must be exactly `ISCC-SIG v1.0`)\n"),
    ]
    controller: Annotated[
        str | None,
        Field(
            description="URI that identifies the key controller\n\n**Examples:**\n- DID: `did:web:example.com`\n- W3C CID Document URL: `https://controller.example/101`\n\n**Note:** CID refers to W3C Controlled Identifier Document, not IPFS CID.\n"
        ),
    ] = None
    keyid: Annotated[
        str | None,
        Field(description="Specific key identifier within the controller document\n"),
    ] = None
    pubkey: Annotated[
        str,
        Field(
            description="Ed25519 public key in multibase format\n\n**Format:** z-base58-btc with ED01 prefix\n**Pattern:** `^z[1-9A-HJ-NP-Za-km-z]+$`\n",
            pattern="^z[1-9A-HJ-NP-Za-km-z]+$",
        ),
    ]
    proof: Annotated[
        str,
        Field(
            description="EdDSA signature in multibase format\n\n**Format:** z-base58-btc encoding\n**Pattern:** `^z[1-9A-HJ-NP-Za-km-z]+$`\n",
            pattern="^z[1-9A-HJ-NP-Za-km-z]+$",
        ),
    ]


class Signature(RootModel[IsccSignature]):
    root: IsccSignature


class IsccNote(Schema):
    model_config = ConfigDict(
        extra="forbid",
    )
    iscc_code: Annotated[
        str,
        Field(
            description="The ISCC-CODE to be declared\n\n**Format:** `ISCC:` followed by alphanumeric characters\n**Note:** Must be a composite ISCC-CODE, not an individual ISCC-UNIT\n**Length:** 34-73 characters total (minimum: Data-Code + Instance-Code 64-bit each)\n",
            examples=[
                "ISCC:KACWN77F73NA44D6EUG3S3QNJIL2BPPQFMW6ZX6CZNOKPAK23S2IJ2I",
                "ISCC:KACXGDR3R7NA44D6RTDMPXW7FBNJS6MYMHYM6JIK7THYC6D2P6KUPCI",
                "ISCC:KUABKF53JEQIDQQ7YU7LB4VHCHGWU",
            ],
            max_length=73,
            min_length=34,
            pattern="^ISCC:[A-Z0-9]{29,68}$",
        ),
    ]
    datahash: Annotated[
        str,
        Field(
            description="Blake3 hash of the declared asset\n\n**Format:** 256-bit lowercase hex-encoded multihash\n**Prefix:** `1e20` (Blake3 identifier)\n**Length:** Exactly 68 characters\n",
            examples=[
                "1e205ca7815adcb484e9a136c11efe69c1d530176d549b5d18d038eb5280b4b3470c",
                "1e201234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
            ],
            max_length=68,
            min_length=68,
            pattern="^1e20[0-9a-f]{64}$",
        ),
    ]
    timestamp: Timestamp
    nonce: Nonce
    signature: Signature
    units: Annotated[
        list[Unit] | None,
        Field(
            description="Array of expanded ISCC-UNITs of the declared ISCC-CODE\n\nFor improved large-scale discovery and matching, include 256-bit ISCC-UNITs.\n\n**Important:** Don't include the Instance-Code as it's derived from the `datahash` property.\n\n**Validation:** The HUB will:\n1. Convert the datahash to an Instance-Code UNIT\n2. Append it to this array\n3. Pass to `iscc_core.gen_iscc_code` to reconstruct the ISCC-CODE\n",
            examples=[
                [
                    "ISCC:AADWN77F73NA44D6X3N4VEUAPOW5HJKGK5JKLNGLNFPOESXWYDVDVUQ",
                    "ISCC:EADSKDNZNYGUUF5AMFEJLZ5P66CP5YKCOA3X7F36RWE4CIRCBTUWXYY",
                    "ISCC:GAD334BLFXWN7QWLCSBGJMLRZW73FFNV7ORVUKN23UWPKGQCWTIHQKY",
                ]
            ],
            max_length=4,
            min_length=1,
        ),
    ] = None
    metahash: Annotated[
        str | None,
        Field(
            description="Blake3 hash of seed metadata (optional)\n\nCreates a cryptographic commitment to the exact metadata state at declaration time.\n\n**Use case:** Allows external registries to store mutable or deletable metadata\nwhile maintaining temporal integrity.\n\n**Format:** 256-bit lowercase hex-encoded multihash\n**Prefix:** `1e20` (Blake3 identifier)\n",
            examples=[
                "1e202335f74fc18e2f4f99f0ea6291de5803e579a2219e1b4a18004fc9890b94e598",
                "1e20abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
            ],
            max_length=68,
            min_length=68,
            pattern="^1e20[0-9a-f]{64}$",
        ),
    ] = None
    gateway: Annotated[
        str | None,
        Field(
            description="URL or URI Template (RFC 6570) for metadata and service discovery\n\n**Supported template variables:**\n- `{iscc_id}` - The assigned ISCC-ID\n- `{iscc_code}` - The declared ISCC-CODE\n- `{pubkey}` - The public key from signature\n- `{datahash}` - The data hash\n- `{controller}` - The key controller from signature\n\n**Requirements:** Must use HTTP or HTTPS scheme\n",
            examples=[
                "https://example.com/metadata",
                "https://gateway.iscc.io/iscc_id/{iscc_id}",
                "https://api.example.com/content/{datahash}/metadata",
            ],
            max_length=2048,
            min_length=8,
            pattern="^https?://[^\\s]+",
        ),
    ] = None


class Declaration(Schema):
    model_config = ConfigDict(
        extra="forbid",
    )
    seq: Annotated[
        int,
        Field(
            description="Gapless sequence number in the event log\n\n**Start:** 0 (first declaration)\n**Guarantee:** No gaps in sequence\n",
            ge=0,
        ),
    ]
    iscc_id: IsccId
    iscc_note: IsccNote


class CredentialSubject(Schema):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Annotated[
        AnyUrl,
        Field(
            description="DID of the subject (signer of the IsccNote)\n",
            examples=["did:key:z6MkhaXgBZDvotDkL5257faiztiGiC2QtKLGpbnnEGta2doK"],
        ),
    ]
    declaration: Annotated[
        Declaration,
        Field(description="Declaration details including sequence number and ISCC-ID\n"),
    ]


class IsccReceipt(Schema):
    model_config = ConfigDict(
        extra="forbid",
    )
    field_context: Annotated[
        list[str],
        Field(
            alias="@context",
            description="JSON-LD context for the Verifiable Credential\n",
            examples=[["https://www.w3.org/ns/credentials/v2"]],
            min_length=1,
        ),
    ]
    type: Annotated[
        list[str],
        Field(
            description="Types of the credential\n\nMust include at least `VerifiableCredential` and `IsccReceipt`\n",
            examples=[["VerifiableCredential", "IsccReceipt"]],
            min_length=2,
        ),
    ]
    issuer: Annotated[
        AnyUrl,
        Field(
            description="DID of the ISCC-HUB issuing this credential\n",
            examples=["did:web:hub.example.com"],
        ),
    ]
    credentialSubject: Annotated[
        CredentialSubject,
        Field(description="Claims about the subject of the credential\n"),
    ]
    proof: Annotated[
        Proof,
        Field(
            description="W3C Data Integrity proof created by ISCC-HUB\n\nUses **EdDSA-JCS-2022** cryptosuite with Ed25519 signatures.\nContains copied @context from credential root per W3C spec.\n"
        ),
    ]
